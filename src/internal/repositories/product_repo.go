package repos

import (
	"errors"
	"scti/internal/models"

	"gorm.io/gorm"
)

type ProductRepo struct {
	DB *gorm.DB
}

func NewProductRepo(db *gorm.DB) *ProductRepo {
	return &ProductRepo{DB: db}
}

func (r *ProductRepo) CreateProduct(product *models.Product) error {
	return r.DB.Create(product).Error
}

func (r *ProductRepo) GetProductByID(id string) (*models.Product, error) {
	var product models.Product
	if err := r.DB.Where("id = ?", id).First(&product).Error; err != nil {
		return nil, err
	}
	return &product, nil
}

func (r *ProductRepo) GetProductsByEventID(eventID string) ([]models.Product, error) {
	var products []models.Product
	if err := r.DB.Where("event_id = ?", eventID).Find(&products).Error; err != nil {
		return nil, err
	}
	return products, nil
}

func (r *ProductRepo) UpdateProduct(product *models.Product) error {
	return r.DB.Save(product).Error
}

func (r *ProductRepo) DeleteProduct(id string) error {
	return r.DB.Where("id = ?", id).Delete(&models.Product{}).Error
}

func (r *ProductRepo) CreatePurchase(purchase *models.Purchase) error {
	return r.DB.Create(purchase).Error
}

func (r *ProductRepo) GetUserPurchases(userID string) ([]models.Purchase, error) {
	var purchases []models.Purchase
	if err := r.DB.Where("user_id = ?", userID).Find(&purchases).Error; err != nil {
		return nil, err
	}
	return purchases, nil
}

func (r *ProductRepo) GetUserByID(userID string) (models.User, error) {
	var user models.User
	if err := r.DB.Where("id = ?", userID).First(&user).Error; err != nil {
		return models.User{}, err
	}
	return user, nil
}

func (r *ProductRepo) GetEventByID(eventID string) (*models.Event, error) {
	var event models.Event
	if err := r.DB.Where("id = ?", eventID).First(&event).Error; err != nil {
		return nil, err
	}
	return &event, nil
}

func (r *ProductRepo) GetEventBySlug(slug string) (*models.Event, error) {
	var event models.Event
	if err := r.DB.Where("slug = ?", slug).First(&event).Error; err != nil {
		return nil, err
	}
	return &event, nil
}

func (r *ProductRepo) GetAdminStatusForEvent(userID string, eventID string) (models.AdminStatus, error) {
	var adminStatus models.AdminStatus
	if err := r.DB.Where("user_id = ? AND event_id = ?", userID, eventID).First(&adminStatus).Error; err != nil {
		return models.AdminStatus{}, err
	}
	return adminStatus, nil
}

func (r *ProductRepo) IsUserRegisteredToEvent(userID string, eventID string) (bool, error) {
	var count int64
	err := r.DB.Model(&models.EventRegistration{}).
		Where("user_id = ? AND event_id = ?", userID, eventID).
		Count(&count).Error

	if err != nil {
		return false, err
	}

	return count > 0, nil
}

func (r *ProductRepo) CreateUserProduct(userProduct *models.UserProduct) error {
	return r.DB.Create(userProduct).Error
}

func (r *ProductRepo) CreateUserToken(userToken *models.UserToken) error {
	return r.DB.Create(userToken).Error
}

func (r *ProductRepo) GetUserProductByUserIDAndProductID(userID string, productID string) ([]models.UserProduct, error) {
	var userProducts []models.UserProduct
	if err := r.DB.Where("user_id = ? AND product_id = ?", userID, productID).Find(&userProducts).Error; err != nil {
		return nil, err
	}
	return userProducts, nil
}

func (r *ProductRepo) GetUserProducts(userID string) ([]models.UserProduct, error) {
	var userProducts []models.UserProduct
	if err := r.DB.Where("user_id = ?", userID).Find(&userProducts).Error; err != nil {
		return nil, err
	}
	return userProducts, nil
}

func (r *ProductRepo) GetUserTokens(userID string) ([]models.UserToken, error) {
	var userTokens []models.UserToken
	if err := r.DB.Where("user_id = ?", userID).Find(&userTokens).Error; err != nil {
		return nil, err
	}
	return userTokens, nil
}

// This function just checks if no errors will be generated by trying to create a purchase record
// For example if no duplicate key errors will be generated
// It should not create a record
// If the transaction finishes without errors, rollback the transaction and send nil
// If there is an error, return the error and rollback the transaction
func (r *ProductRepo) SimulatePurchase(purchase *models.Purchase) error {
	tx := r.DB.Begin()
	if tx.Error != nil {
		return errors.New("failed to begin simulation transaction: " + tx.Error.Error())
	}

	// Try to create the purchase in the transaction
	if err := tx.Create(purchase).Error; err != nil {
		tx.Rollback()
		return err
	}

	// Rollback the transaction even if successful
	return tx.Rollback().Error
}

// SimulateUserProduct checks if creating a user product would succeed without committing to the database
func (r *ProductRepo) SimulateUserProduct(userProduct *models.UserProduct) error {
	tx := r.DB.Begin()
	if tx.Error != nil {
		return errors.New("failed to begin simulation transaction: " + tx.Error.Error())
	}

	if err := tx.Create(userProduct).Error; err != nil {
		tx.Rollback()
		return err
	}

	return tx.Rollback().Error
}

// SimulateUserToken checks if creating a user token would succeed without committing to the database
func (r *ProductRepo) SimulateUserToken(userToken *models.UserToken) error {
	tx := r.DB.Begin()
	if tx.Error != nil {
		return errors.New("failed to begin simulation transaction: " + tx.Error.Error())
	}

	if err := tx.Create(userToken).Error; err != nil {
		tx.Rollback()
		return err
	}

	return tx.Rollback().Error
}

// SimulateUpdateProduct checks if updating a product would succeed without committing to the database
func (r *ProductRepo) SimulateUpdateProduct(product *models.Product) error {
	tx := r.DB.Begin()
	if tx.Error != nil {
		return errors.New("failed to begin simulation transaction: " + tx.Error.Error())
	}

	if err := tx.Model(product).Update("quantity", product.Quantity).Error; err != nil {
		tx.Rollback()
		return err
	}

	return tx.Rollback().Error
}
